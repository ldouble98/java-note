# tcp 三次握手 四次挥手
![tcp三次握手 四次挥手](tcp.png)

```
1. 客户端问服务器准备好了吗？
2.1 服务器回准备好了，
2.2 服务器问客户端准备好了吗?
3 客户端回准备好了

服务端客户端 建立连接
1 客户端发出结束请求
2 服务端向客户端发我接收了 
3 服务端向客户端发出关闭收信息 （这里发出结束请求的客户端 会等2个传输报文的时间）
4 客户端向客户端发ack确认信息

这里2、3不能合为一步的原因：
    1.服务端close 是我们主动调用close、在2 服务端收到请求，而这时还没有
       关闭资源，这时因为tcp是可靠协议不能一直等，就先将我收到请求返回
    2.服务端在发出关闭收信息时，客户端还要回一个确认，所以在3返回后，客户端收到信息，
      这时不能立刻关闭客户端，因为在4步骤中可能会发生报文丢失等服务端没有收到应答信息，
      这是服务器会重新发送信息给客户端。

```

一、保证TCP协议的全双工连接能够可靠关闭

二、保证这次连接的重复数据段从网络中消失


先说第一点，如果Client直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，
导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，
此时由于Client已经CLOSED了，就找不到与重发的FIN对应的连接，最后Server就会收到
RST而不是ACK，Server就会以为是连接错误把问题报告给高层。这样的情况虽然不会造成
数据丢失，但是却导致TCP协议不符合可靠连接的要求。所以，Client不是直接进入CLOSED，
而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。


再说第二点，如果Client直接CLOSED，然后又再向Server发起一个新连接，
我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接
和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新
连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些
延迟数据在建立新连接之后才到达Server，由于新连接和老连接的端口号是一样的，又因为
TCP协议判断不同连接的依据是socket pair，于是，TCP协议就认为那个延迟的数据是属于新
连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状
态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。
